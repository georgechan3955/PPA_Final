---
title: "Gentrification Prediction Model for the City of Los Angeles"
author: "George Chen, Jiahang Li, Xiayuanshan Gao"
date: "2024-05-07"
output: 
  html_document:
    toc: true
    toc_float: true
    code_folding: hide
    number_sections: yes
    theme: cosmo 
    highlight: tango    
editor_options: 
  markdown: 
    wrap: 72
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(message = FALSE, warning = FALSE, echo = FALSE,cache=TRUE)

options(scipen=999)
```

```{r}
library(tidyverse)
library(sf)
library(spdep)
library(caret)
library(ckanr)
library(FNN)
library(grid)
library(gridExtra)
library(ggcorrplot) # plot correlation plot
library(corrr)      # another way to plot correlation plot
library(kableExtra)
library(jtools)     # for regression model plots
library(ggstance) # to support jtools plots
library(ggpubr)    # plotting R^2 value on ggplot point scatter
library(broom.mixed) # needed for effects plots
library(RColorBrewer)
library(RSocrata)

library(RSocrata)
library(viridis)
library(spatstat)
library(spdep)
library(FNN)
library(knitr)
library(kableExtra)
library(tidycensus)

root.dir = "https://raw.githubusercontent.com/urbanSpatial/Public-Policy-Analytics-Landing/master/DATA/"
source("https://raw.githubusercontent.com/urbanSpatial/Public-Policy-Analytics-Landing/master/functions.r")

palette5 <- c("#7892B5","#8CB9C0","#91B5A9","#EDCA7F","#D98481")
palette4 <- c("#7892B5","#8CB9C0","#EDCA7F","#D98481")
palette2 <- c("#7892B5","#D98481")

```

# Introduction


Predicting and managing urban gentrification is increasingly crucial for city planners and policymakers aiming to balance economic growth with community sustainability. This report introduces  a predictive model for gentrification, focusing on its application on  identifying areas at risk within Los Angeles City. The project leverages spatial and census data from 2015 to 2020 for the City of Los Angeles, integrating key metrics such as property values, demographic shifts, and local amenities to construct a robust model of urban transformation.  

# Data Collection

Our project tests a combination of spatial and non-spatial data to construct a comprehensive predictive model of gentrification in Los Angeles. The spatial data encompasses geographical boundaries of census tracts, locations of amenities such as grocery stores, restaurants, educational facilities, and transit stations. Non-spatial data comprises demographic and socioeconomic variables derived from the American Community Survey (2015-2020), which include population density, age distribution, ethnic composition, income levels, education levels, housing characteristics, and migration patterns.


## Spatial Data

### Metro Station

```{r cache = TRUE, message = FALSE, warning = FALSE,results='hide'}

# Reading neighborhood boundaries GeoJSON from the raw GitHub URL and transforming CRS
boundary <- st_read("CityBoundaryofLosAngeles.geojson")%>%
st_transform('ESRI:102645')

metro <- 
  st_read("data/Metro_Stations.geojson")%>%
  st_transform('ESRI:102645')
```

### Grocery store

```{r}
grocerystore <- read.socrata("https://data.lacity.org/resource/g986-7yf9.json")

# Clean and process the data
grocerystore <- grocerystore %>%
  dplyr::select(location_1.latitude, location_1.longitude) %>%
  na.omit() %>%
  st_as_sf(coords = c("location_1.longitude", "location_1.latitude"), crs = 4326, agr = "constant")%>%
 st_transform('ESRI:102645')
```


### Restaurant

```{r}

restaurant <- read.socrata("https://data.lacity.org/resource/ieer-tbdq.json")

restaurant <- restaurant %>%
  dplyr::select(Y = location_1.latitude, X = location_1.longitude) %>%
  na.omit() %>%
  st_as_sf(coords = c("X", "Y"), crs = 4326, agr = "constant") %>% # Transforming to the specified CRS
st_transform('ESRI:102645')

```

### Education Facities

```{r cache = TRUE, message = FALSE, warning = FALSE,results='hide'}
educationfacilities <- 
 st_read("https://services.arcgis.com/RmCCgQtiZLDCtblq/arcgis/rest/services/Schools_Colleges_and_Universities/FeatureServer/0/query?outFields=*&where=1%3D1&f=geojson") 

educationfacilities <- educationfacilities %>%
dplyr::select(Y = latitude, X = longitude) %>%
  na.omit() %>%
  st_as_sf(coords = c("X", "Y"), crs = 4326, agr = "constant")%>%  # Transforming to the specified CRS
  st_transform('ESRI:102645')
```

### Crime Data 2015 and 2020

```{r}

crime2015 <- 
  read.socrata("https://data.lacity.org/Public-Safety/Crime-Data-from-2010-to-2019/63jg-8b9z/") %>%
  mutate(year = substr(date_rptd,1,4)) %>% filter(year == "2015") %>%
  dplyr::select(Y = lat, X = lon) %>%
  na.omit() %>%
  st_as_sf(coords = c("X", "Y"), crs = 4326, agr = "constant") %>%
  st_transform('ESRI:102645')
  
```

```{r}
crime2020 <- 
  read.socrata("https://data.lacity.org/Public-Safety/Crime-Data-from-2020-to-Present/2nrs-mtv8/") %>%
  mutate(year = substr(date_rptd,1,4)) %>% filter(year == "2020") %>%
  dplyr::select(Y = lat, X = lon) %>%
  na.omit() %>%
  st_as_sf(coords = c("X", "Y"), crs = 4326, agr = "constant") %>%
  st_transform('ESRI:102645')
  
```


### Census Data 2015 and 2020

As current studies mentioned the impact of historical racial segregation (Hwang & Sampson, 2014) and migration (Hwang et al., 2015) on gentrification, we give attention to white and minority household ownership proportions and migration rates. We also consider more demographic variables referencing the study of DeVylder et al. (2019), including gender, age group, annual household income, and education level. We refined the raw census data to calculate percentage representations for critical metrics. This normalization allows us to assess gentrification impacts relative to the total population per tract, ensuring comparability across diverse geographic regions. Changes in key socioeconomic indicators over time (2015-2020) were computed to capture the dynamics of gentrification. These include changes in poverty levels, educational attainment, and racial demographics. 


```{r cache = TRUE, message = FALSE, warning = FALSE,results='hide'}


census_api_key("f681592f0e7bc7e399e41102649c493ec7f7f574") 

variables <- c("B01001_001E",
  "B01001_002E",
  "B01001_026E",
   "B01001_007E",
  "B01001_012E",
   "B01001_016E",
 "B01001_020E","B02001_002E","B02001_003E", "B03001_003E", "B02001_004E", "B19001_002E","B19001_003E", "B19001_006E", "B19001_008E",
"B19001_010E", "B19001_012E","B07001_001E","B07001_017E","B07001_033E",
"B07001_049E",
"B07001_065E",
  "B15001_002E",
 "B15001_003E",
"B15001_005E",
"B15001_009E",
"B15001_010E",
   "B25001_001E",
  "B06012_002E",
  "B25002_003E",
"B25006_002E",
  "B25006_001E",
  "B19013_001E",
"B25077_001E",
"B25031_001",
"B08133_001"
)



# Fetch the data for LA, LA County, CA,2015
acs_la <- get_acs(
  geography = "tract",
  variables = variables,
  year = 2015,
  state = "06",
  county = "037",
  geometry = TRUE,
  survey = "acs5",
  output = "wide"
)%>%
st_transform('ESRI:102645')



# Fetch the data for LA, LA County, CA,2020
acs_la20 <- get_acs(
  geography = "tract",
  variables = variables,
  year = 2020,
  state = "06",
  county = "037",
  geometry = TRUE,
  survey = "acs5",
  output = "wide"
)%>%
  st_transform('ESRI:102645')
vars <- load_variables(2020, "acs5", cache = TRUE)

```


```{r}

acs_la <- acs_la %>%
  rename(
    totalPop = B01001_001E,
    male = B01001_002E,
    female = B01001_026E,
    age_18_24 = B01001_007E,
    age_25_44 = B01001_012E,
    age_45_64 = B01001_016E,
    age_65plus = B01001_020E,
    white = B02001_002E,
    popblack = B02001_003E,
    latino = B03001_003E,
    other_race = B02001_004E,
    income_less_20k = B19001_002E,
    income_20k_40k = B19001_003E,
    income_40k_60k = B19001_006E,
    income_60k_80k = B19001_008E,
    income_80k_100k = B19001_010E,
    income_more_100k = B19001_012E,
    migration_total = B07001_001E,
    migration_within_county = B07001_017E,
    migration_different_county_same_state = B07001_033E,
    migration_different_state = B07001_049E,
    migration_from_abroad = B07001_065E,
    edu_less_high_school = B15001_002E,
    edu_high_school_grad = B15001_003E,
    edu_some_college = B15001_005E,
    edu_bachelors = B15001_009E,
    edu_grad_professional = B15001_010E,
    total_housing_units = B25001_001E,
    total_poverty = B06012_002E,
    vacant_units = B25002_003E,
    white_houseOwner = B25006_002E,
    total_occupied_units = B25006_001E,
    median_HH_income = B19013_001E,
    houseprice = B25077_001E,
    rent = B25031_001E,
    travetimetowork = B08133_001E
  ) %>%
  select(-starts_with("B"),-NAME) %>%
  mutate(
    WhiteHOrate = white_houseOwner / total_occupied_units,
    pctBachelors = ifelse(totalPop > 0, (edu_bachelors + edu_grad_professional) / totalPop, 0),
    pctPoverty = ifelse(totalPop > 0, total_poverty / totalPop, 0),
    pctWhitePop = ifelse(totalPop > 0, white / totalPop, 0),
    pctLatinoPop = ifelse(totalPop > 0, latino / totalPop, 0),
    pctBlackPop = ifelse(totalPop > 0, popblack / totalPop, 0),
    pctMigration = ifelse(totalPop > 0, migration_total / totalPop, 0),
    pctForeignMig = ifelse(totalPop > 0, migration_from_abroad / totalPop, 0),
    pct2540 = ifelse(totalPop > 0,  age_25_44 / totalPop, 0),
    landArea = st_area(geometry), 
    popDensity = totalPop / as.numeric(landArea)
  )

```

```{r}

acs_la20 <- acs_la20 %>%
  rename(totalPop20 = "B01001_001E",
  male20 = "B01001_002E",
  female20 = "B01001_026E",
  age_18_2420 = "B01001_007E",
  age_25_4420 = "B01001_012E",
  age_45_6420 = "B01001_016E",
  age_65plus20 = "B01001_020E",
  white20 = "B02001_002E",
  popblack20 = "B02001_003E",
  latino20 = "B03001_003E",
  other_race20 = "B02001_004E",
  income_less_20k20 = "B19001_002E",
  income_20k_40k20 = "B19001_003E",
  income_40k_60k20 = "B19001_006E",
  income_60k_80k20 = "B19001_008E",
  income_80k_100k20 = "B19001_010E",
  income_more_100k20 = "B19001_012E",
  migration_total20 = "B07001_001E",
  migration_within_county20 = "B07001_017E",
  migration_different_county_same_state20 = "B07001_033E",
  migration_different_state20 = "B07001_049E",
  migration_from_abroad20 = "B07001_065E",
  edu_less_high_school20 = "B15001_002E",
  edu_high_school_grad20 = "B15001_003E",
  edu_some_college20 = "B15001_005E",
  edu_bachelors20 = "B15001_009E",
  edu_grad_professional20 = "B15001_010E",
  total_housing_units20 = "B25001_001E",
  total_poverty20 = "B06012_002E",
  vacant_units20 = "B25002_003E",
  white_houseOwner20 = "B25006_002E",
  total_Ooccupied_Uunits20 = "B25006_001E",
  median_HH_income20 = "B19013_001E",
  houseprice20 = "B25077_001E",
  rent20="B25031_001E"
)%>%
  dplyr::select(-starts_with("B")) %>% 
  mutate(WhiteHOrate20 = white_houseOwner20/total_Ooccupied_Uunits20,
         pctBachelors20 = ifelse(totalPop20 > 0, ((edu_bachelors20 + edu_grad_professional20) / totalPop20),0),
         pctPoverty20 = ifelse(totalPop20 > 0, total_poverty20 / totalPop20, 0),
         pctWhitePop20 = ifelse(totalPop20 > 0, white20 / totalPop20, 0),
         pctLatinoPop20 = ifelse(totalPop20 > 0, latino20 / totalPop20, 0),
         pctBlackPop20 = ifelse(totalPop20 > 0, popblack20 / totalPop20, 0),
         pctMigration20 = ifelse(totalPop20 > 0, migration_total20 / totalPop20, 0),
         pctForeignMig20 = ifelse(totalPop20 > 0, migration_from_abroad20 / totalPop20, 0),
         pct254020 = ifelse(totalPop20 > 0,  age_25_4420 / totalPop20, 0),
         landArea20 = st_area(geometry), 
         popDensity20 = totalPop20 / as.numeric(landArea20))
```






# Measuring Gentrification


In our study, we adopted a refined approach to measuring gentrification, drawing upon the methodologies described in prior research, particularly from the National Community Reinvestment Coalition (NCRC) guidelines. Our primary aim was to identify census tracts that underwent significant socio-economic changes indicative of gentrification. To this end, we set criteria based on changes observed from 2015 to 2020, utilizing the American Community Survey (ACS) five-year data sets.

The criteria for defining a tract as gentrified were based on several key indicators:

**Population Eligibility**: Originally, tracts with a population greater than 500 were considered to be eligible tracts for further analysis, but in order to capture all information from the census tract data, we decided to use all tracts instead of the tracts with a population greater than 500 based on the 2014. Eligible tracts would also fit the following criteria in order to be included for further analysis: Median Home Value < 40th percentile and Median Household income < 40th percentile.

**Socioeconomic Indicators**: We assessed changes in median home values, median household income, and the percentage of residents with a college education. A tract was considered at risk of gentrification if it experienced: 
An increase in median home value and median household income greater than the 40th percentile citywide, rather than the 60th percentile as outlined in the original NCRC model. This adjustment was made to capture more subtle yet significant shifts that may not reach the higher threshold but still represent meaningful change.
An increase in the proportion of college-educated residents, also above the 40th percentile, to reflect educational gentrification.

**Metropolitan level Comparison**: All data was loaded, calculated, and filtered in the Metropolitan level scale instead of trimming to the city area at the beginning and operating in the city scale, which would allow the gentrification identification to be more accurate, reflecting the gentrification trend in the ambient tracts.

Tracts based on 2020 census information meeting these criterias were classified as 'gentrified' (1) and all others as 'non-gentrified' (0).  This methodological approach helps pinpoint the tracts most affected by gentrification based on significant socio-economic transformations. By lowering the percentile threshold for income and home value increases, we include areas undergoing earlier stages of gentrification, which are crucial for timely policy interventions.




```{r cache = TRUE, message = FALSE, warning = FALSE,results='hide'}

library(tidycensus)
library(dplyr)
library(sf)
library(ggplot2)


# labor force: B16010_041
# empolymentL:B23006_023
# Define variables for ACS data retrieval

variable <- c(med_income = "B19013_001E",  # Median household income
               total_bachelors = "B16010_041E",  # with Bachelor's degree or higher
               med_home_value = "B25077_001E")  # Median home value



# Fetch ACS data for 2010 and 2015
acs2014 <- get_acs(geography = "tract", variables = variable, year = 2014, 
                   survey = "acs5", state = 06, county = 037, geometry = TRUE,output = "wide") 
# %>% 

acs2020 <- get_acs(geography = "tract", variables = variable, year = 2020, 
                   survey = "acs5", state = 06, county = 037, geometry = TRUE,output = "wide") %>% 
  select(-matches("M$"))%>% 
st_transform('ESRI:102645')

acs2015 <- get_acs(geography = "tract", variables = variable, year = 2015, 
                   survey = "acs5", state = 06, county = 037, geometry = TRUE,output = "wide") %>% 
  select(-matches("M$"))%>% 
st_transform('ESRI:102645')


# Drop geometry for joining data on attributes
acs2014_nogeom <- st_drop_geometry(acs2014)
acs2020_nogeom <- st_drop_geometry(acs2020)
acs2015_nogeom <- st_drop_geometry(acs2015)

acs2014_nogeom <- acs2014_nogeom %>%
  rename_with(~paste0(., ".2014"), matches("^med_income|^total_bachelors|^med_home_value"))

acs2020_nogeom <- acs2020_nogeom %>%
  rename_with(~paste0(., ".2020"), matches("^med_income|^total_bachelors|^med_home_value"))
acs2015_nogeom <- acs2015_nogeom %>%
  rename_with(~paste0(., ".2015"), matches("^med_income|^total_bachelors|^med_home_value"))

gentrified_data <- left_join(acs2014_nogeom, acs2020_nogeom, by = "GEOID") %>%
  left_join(acs2015_nogeom, by = "GEOID")
gentrified_data <- gentrified_data %>%
  mutate(
    income_change_2020_2015 = (`med_income.2020` - `med_income.2015`) / `med_income.2015` * 100,
    education_change_2020_2015 = (`total_bachelors.2020` - `total_bachelors.2015`) / `total_bachelors.2015` * 100,
    home_value_change_2020_2015 = (`med_home_value.2020` - `med_home_value.2015`) / `med_home_value.2015` * 100,) %>% 
  select(-matches("^NAME"))
   
# Convert it back
gentrified_data_sf <- st_as_sf(gentrified_data, geometry = st_geometry(acs2014), crs = st_crs(acs2014))

```



```{r cache = TRUE, message = FALSE, warning = FALSE}

# Assuming data_sf is already loaded and contains the necessary columns

# Calculate thresholds for 2009
thresholds_2014 <- gentrified_data_sf %>%
  summarise(
    threshold_home_value_2014 = quantile(med_home_value.2014, 0.4, na.rm = TRUE),
    threshold_income_2014 = quantile(med_income.2014, 0.4, na.rm = TRUE)
  )

# Convert thresholds to a simpler format if needed (depending on the context)
thresholds_2014 <- as.data.frame(thresholds_2014)

# Define eligibility in 2009 based on population, home value, and income
eligible_tracts <- gentrified_data_sf %>%
  filter(#population.2009 > 500,
         med_home_value.2014 < thresholds_2014$threshold_home_value_2014,
         med_income.2014 < thresholds_2014$threshold_income_2014)

# Calculate changes from 2010 to 2015
changes_2020_2015 <- eligible_tracts %>%
  mutate(
    home_value_change = med_home_value.2020 - med_home_value.2015,
    income_change = med_income.2020 - med_income.2015,
    education_change = total_bachelors.2020 - total_bachelors.2015
  )

# Calculate 60th percentile changes as new thresholds for changes
thresholds_2015 <- changes_2020_2015 %>%
  summarise(
    top_40th_home_value_change = quantile(home_value_change, 0.4, na.rm = TRUE),
    top_40th_income_change = quantile(income_change, 0.4, na.rm = TRUE),
    top_40th_education_change = quantile(education_change, 0.4, na.rm = TRUE)
  )

# Convert to a simpler format
thresholds_2015 <- as.data.frame(thresholds_2015)

# Apply change criteria for 2010-2015
gentrified_tracts <- changes_2020_2015 %>%
  filter(home_value_change > thresholds_2015$top_40th_home_value_change,
         #home_value_change >0,
         income_change > thresholds_2015$top_40th_income_change,
         education_change > thresholds_2015$top_40th_education_change)


gentrified_tracts <- gentrified_tracts %>%
  dplyr::select(GEOID,geometry)

gentrified_tractsnew <- st_drop_geometry(gentrified_tracts)%>%
   mutate(gentrification = 1)



# Switch to your own path, Xia and Jiahang!
la_city_boundary <- st_read("CityBoundaryofLosAngeles.geojson") %>%
st_transform(st_crs(gentrified_tracts))


# THIS IS THE DATASET!!!!!!!!!
gentrified_tracts_LA <- st_intersection(gentrified_tracts, la_city_boundary)

# Mapping the results
ggplot(gentrified_tracts_LA) +
  geom_sf(data = la_city_boundary, fill = "grey80", color = "black", size = 0.2, alpha = 0.5) +
  geom_sf(fill = "#7892B5", color = "black") +
  labs(title = "Gentrified Areas in 2020, City of LA",
       subtitle = "Tracts meeting all criteria for significant changes") +
  theme_minimal()

```



# Feature Engineering

## Census data

As current studies mentioned the impact of historical racial segregation (Hwang & Sampson, 2014) and migration (Hwang et al., 2015) on gentrification, we give attention to white and minority household ownership proportions and migration rates. We also consider more demographic variables referencing the study of DeVylder et al. (2019), including gender, age group, annual household income, and education level. We refined the raw census data to calculate percentage representations for critical metrics. This normalization allows us to assess gentrification impacts relative to the total population per tract, ensuring comparability across diverse geographic regions. Changes in key socioeconomic indicators over time (2015-2020) were computed to capture the dynamics of gentrification. These include changes in poverty levels, educational attainment, and racial demographics.

```{r cache = TRUE, message = FALSE, warning = FALSE,results='hide'}
library(sf)
library(dplyr)

# Drop geometry from acs_la and acs_la20 and join them
acs_la_nogeom <- st_drop_geometry(acs_la)
acs_la20_nogeom <- st_drop_geometry(acs_la20)
data <- left_join(acs_la_nogeom, acs_la20_nogeom, by = "GEOID")


# Convert acs2015 to a spatial dataframe and select relevant columns
datageography <- st_as_sf(acs2015, geometry = "geometry", crs = 4326) %>%
  select(GEOID, geometry)

# Joining non-spatial data with spatial data and ensuring it remains a spatial dataframe
datanew <- left_join(data, datageography, by = "GEOID")
datanew <- st_as_sf(datanew, geometry = st_geometry(acs_la), crs = st_crs(acs_la))

# Read and transform the boundary to match LA's local projection
boundary <- st_read("CityBoundaryofLosAngeles.geojson") %>%
  st_transform(crs = 'ESRI:102645')

# Transform datanew to match the CRS of boundary
datanew <- st_transform(datanew, st_crs(boundary))

# Perform the intersection of boundary and datanew
tractclipped <- st_intersection(boundary, datanew)

# Select GEOID and geometry from the intersection result
tractgeography <- tractclipped %>%
  select(GEOID, geometry)

# Correcting the assignment and ensuring proper use of the pipe operator
tractclippednew <- tractclipped %>%
  left_join(gentrified_tractsnew[, c("GEOID", "gentrification")], by = "GEOID")

# Assuming your dataframe is called 'data'
tractclippednew <- tractclippednew %>%
  mutate(gentrification = replace_na(gentrification, 0))

```

```{r}

tractclippednew <- tractclippednew  %>%
  mutate(changeinpoverty = pctPoverty20 - pctPoverty,
         changeinbachelor = pctBachelors20 - pctBachelors,
         changeinwhite = pctWhitePop20 - pctWhitePop,
         changeinhouseprice=houseprice20-houseprice,
         changeinrent=rent20-rent,
         changein2544= pct254020- pct2540,
         newhousingunit=total_housing_units20-total_housing_units,
         migChange = pctMigration20 - pctMigration20, 
         incomeChange = median_HH_income20 - median_HH_income, 
         minorityChange = (1-pctWhitePop20) - (1-pctWhitePop),
         ForMig_Change = pctForeignMig20 - pctForeignMig,
         Density_Change = popDensity20 - popDensity)
```



## Amenity Accessibility

We conducted spatial joins between census tracts and points of interest to count the number of amenities within each tract. This process included grocery stores, housing permits (indicative of development activity), restaurants, and educational facilities, providing a lens into the changing infrastructural landscape which often accompanies or signals gentrification.


### identify number of grocery stores in each tract

```{r}
grocerystorepoint <- grocerystore %>%
  st_transform(st_crs(tractgeography))%>%
  st_join(tractgeography, left = F)
  
grocerystorenumber <- grocerystorepoint %>%
  group_by(GEOID) %>% 
  summarise(grocerycount = n())
  
grocerystorenumber <- grocerystorenumber
grocerystorenumber <- st_set_geometry(grocerystorenumber, NULL)

gentrifydata <- left_join(tractclippednew, grocerystorenumber )
```




### identify number of restaurants in each tract


```{r}


restaurantpoint <- restaurant %>%
  st_join(tractgeography, left = F)
restaurantnumber <- restaurantpoint %>%
  group_by(GEOID) %>%  
  summarise(restaurantcount = n())
  
restaurantnumber <- restaurantnumber
restaurantnumber <- st_set_geometry(restaurantnumber, NULL)

gentrifydata <- left_join(gentrifydata, restaurantnumber )

```

### identify number of education facilities in each tract

```{r}

educationfacilitiespoint <- educationfacilities %>%
  st_join(tractgeography, left = F)
educationfacilitiesnumber <- educationfacilitiespoint %>%
  group_by(GEOID) %>%  
  summarise(educationfacilitiescount = n())
  
educationfacilitiesnumber <- educationfacilitiesnumber
educationfacilitiesnumber <- st_set_geometry(educationfacilitiesnumber, NULL)


```


## Visualizing amenity patterns

We conducted spatial joins between census tracts and points of interest to count the number of amenities within each tract. This process included grocery stores, housing permits (indicative of development activity), restaurants, and educational facilities, providing a lens into the changing infrastructural landscape which often accompanies or signals gentrification.

```{r}
library(ggplot2)
library(patchwork)


plot_school <- ggplot() +
  stat_density2d(data = data.frame(st_coordinates(educationfacilitiespoint)), 
                 aes(X, Y, fill = ..level.., alpha = ..level..),
                 size = 0.01, bins = 40, geom = 'polygon') +
  scale_fill_gradient(low='#7892B5', high='#fecc5c', name = "Density") +
   geom_sf(data=gentrifydata,fill="transparent", color = "grey")+
  scale_alpha(range = c(0.00, 0.35), guide = FALSE) +
  labs(title="Density of education facilities")+
   theme_void()



plot_grocerystores <- ggplot() +
  geom_sf(data=gentrifydata,fill="transparent", color = "grey")+
  stat_density2d(data = data.frame(st_coordinates(grocerystorepoint)), 
                 aes(X, Y, fill = ..level.., alpha = ..level..),
                 size = 0.01, bins = 40, geom = 'polygon') +
  scale_fill_gradient(low='#7892B5', high='#fecc5c', name = "Density") +
  scale_alpha(range = c(0.00, 0.35), guide = FALSE) +
  labs(title="Density of Grocery Stores")+
   theme_void()



plot_restaurant<- ggplot() +
  geom_sf(data=gentrifydata,fill="transparent", color = "grey")+
  stat_density2d(data = data.frame(st_coordinates(restaurantpoint)), 
                 aes(X, Y, fill = ..level.., alpha = ..level..),
                 size = 0.01, bins = 40, geom = 'polygon') +
  scale_fill_gradient(low='#7892B5', high='#fecc5c', name = "Density") +
  scale_alpha(range = c(0.00, 0.35), guide = FALSE) +
  labs(title="Density of Restaurants",subtitle = "Los Angelas, CA")+
   theme_void()


wrap_plots(
  plot_restaurant, plot_school,  plot_grocerystores,
  ncol = 2  
)


```




# Exploratory Analysis - Gentrification

## Numeric Variables

The following figures are bar charts that represents the mean value of numeric variables within the dataset.

```{r cache = TRUE, warning = FALSE, message = FALSE,fig.width=10, fig.height=10}

gentrifydataplot <- st_set_geometry(gentrifydata, NULL)%>%
na.omit() 

# Convert 'gentrification' to a factor with levels that are valid R variable names
gentrifydataplot$gentrification <- factor(gentrifydataplot$gentrification, levels = c(0, 1), labels = c("No", "Yes"))
numeric_var <- gentrifydataplot %>% 
  select(gentrification, changeinpoverty,changeinbachelor, changeinwhite,pctBachelors20,changein2544,houseprice20,rent,rent20,changeinhouseprice,newhousingunit, incomeChange, ForMig_Change, Density_Change)


numeric_var %>%
  gather(Variable, value, -gentrification) %>%
  ggplot(aes(gentrification, value, fill=gentrification)) + 
    geom_bar(position = "dodge", stat = "summary", fun = "mean") + 
    facet_wrap(~Variable, scales = "free", ncol = 4) +
    scale_fill_manual(values = palette2) +
    labs(x = "Gentrification", y = "Value", 
         title = "Feature Associations with the Likelihood of Gentrification",
         subtitle = "Numeric Features") +
    theme(legend.position = "none",
          plot.subtitle = element_text(size = 12, face = "italic"),
          plot.title = element_text(size = 18, face = "bold"), 
          axis.text.x = element_text(size = 10),
          axis.text.y = element_text(size = 10), 
          axis.title = element_text(size = 12), 
          panel.background = element_blank(),
          panel.border = element_rect(colour = "grey", fill = NA, linewidth = 0.8))


```

```{r fig.height=10, fig.width=16, message=FALSE, warning=FALSE, cache=TRUE}
numeric_var %>%
    gather(Variable, value, -gentrification) %>%
    ggplot() + 
    geom_density(aes(value, color=gentrification), fill = "transparent") + 
   facet_wrap(~Variable, scales = "free", ncol = 4) +
  scale_color_manual(values = palette2) +
    labs(title = "Feature Distributions Based on Recidivism",
         subtitle = "Continous features") +
  theme(plot.subtitle = element_text(size = 12,face = "italic"),
        plot.title = element_text(size = 18, face = "bold"), 
        axis.text.x=element_text(size=9),
        axis.text.y=element_text(size=9), 
        axis.title=element_text(size=9), 
        panel.background = element_blank(),
        panel.border = element_rect(colour = "grey", fill=NA, linewidth =0.8))
```









## Crime Data Integration

To understand the relationship between safety and gentrification, we compiled crime statistics for 2015 and 2020, calculating changes over time to discern any correlations between gentrification and crime rates. The following maps illustrate the change in crime density across Los Angeles from 2015 to 2020, it can be observed a decrease in crime density in the upper town area within the tracts with relatively high crime numbers per tract. This rich dataset allows for a nuanced analysis of how various factors contribute to or are affected by gentrification, providing city planners with actionable insights into urban development processes.


```{r}
crime2015point <- crime2015 %>%
  st_join(tractgeography, left = F)
crime2015number <- crime2015point %>%
  group_by(GEOID) %>%  
  summarise(crime2015count = n())
  
crime2015number <- crime2015number
crime2015number <- st_set_geometry(crime2015number, NULL)

gentrifydata <- left_join(gentrifydata, crime2015number, by = c("GEOID"))
```

```{r}
crime2020point <- crime2020 %>%
  st_join(tractgeography, left = F)
crime2020number <- crime2020point %>%
  group_by(GEOID) %>%  # Replace TRACT_ID with the actual identifier field for tracts
  summarise(crime2020count = n())
  
crime2020number <- crime2020number
crime2020number <- st_set_geometry(crime2020number, NULL)

gentrifydata <- left_join(gentrifydata,crime2020number, by = c("GEOID"))
```

```{r}
gentrifydata <- gentrifydata %>%
  mutate(crimeChange = crime2020count - crime2015count)

```



```{r}
plot_crime2015 <- ggplot(data = gentrifydata, aes(fill = crime2015count)) +
  geom_sf() +
  scale_fill_viridis_c(option = "plasma", name = "Crime Count 2015") +
  labs(title = "Density of Crime in 2015", subtitle = "Los Angeles, CA") +
  theme_void() +
  theme(legend.position = "bottom")

plot_crime2020 <- ggplot(data = gentrifydata, aes(fill = crime2020count)) +
  geom_sf() +
  scale_fill_viridis_c(option = "plasma", name = "Crime Count 2020") +
  labs(title = "Density of Crime in 2020", subtitle = "Los Angeles, CA") +
  theme_void() +
  theme(legend.position = "bottom")

crime_plots <- plot_crime2015 + plot_crime2020 + 
                  plot_layout(ncol = 2)  # Arrange the plots in 2 columns

# Print the combined plot
print(crime_plots)

ggsave("crime.png", plot = crime_plots, bg = "transparent", width = 10, height = 8, dpi = 300)

```


# Logistic regression

As we measured gentrification with binary classification, we chose logistic regression to predict gentrification in Los Angeles because it effectively models the probability of each census tract becoming gentrified based on socio-economic and demographic predictors. We finally involved a list of demographic and socio-economic predictors, include:

* **gentrification:** An index using 0 and 1 to indicate whether a tract has gentrified. 0 for no and 1 for yes.

* **incomeChange: ** income change from 2015 to 2020

* **changeinpovwerty:** Change in percentage of poverty from 2015 to 2020

* **ForMig_Change:** Change in percentage of migration from 2015 to 2020

* **changeinbachelor: **Change in percentage of people with at least a bachelor degree from 2015 to 2020

* **housingprice20:** Median rent price per tract in 2020

* **changeinhouseprice:** Change in median house price per tract from 2015 to 2020

* **changein2544: ** Change in population aged from 25 to 44 per tract  from 2015 to 2020

* **rent20:** Median rent price per tract in 2020

* **rent:** Median rent price per tract in 2015

* **changeinwhite:** Change in percentage of people with at least a bachelor degree

* **pctBachelors20:** Percentage of people with at least a bachelor's degree in 2020

* **newhousingunit:**  new housing units from 2015 to 2020

* **Race:** the racial context

* **crimeChange:** Crime change number between 2015 and 2020. 

* **Density_Change:** Change in population density between 2015 and 2020

While TOD and amenity features donâ€™t contribute well to the model accuracy so we dropped them in the end.


```{r cache = TRUE, message = FALSE, warning = FALSE,results='hide'}
#colnames(gentrifydata)
```

## Modeling building


```{r}

gentrifydata <- gentrifydata %>%
  mutate(race = ifelse(pctWhitePop < 0.5, "Minority", "White"))
```



```{r}

gentrifydata <- st_set_geometry(gentrifydata, NULL)
# Replace NA values in the 'gentrification' column with 0 (or another appropriate value)
set.seed(479)
trainIndex <- createDataPartition(y = paste(gentrifydata) , p = .65,
                                  list = FALSE,
                                  times = 1)
```



```{r}
gentrifydataTrain <- gentrifydata[ trainIndex,]
gentrifydataTest  <- gentrifydata[-trainIndex,]

gentrifyModel <- glm(gentrification ~ .,data=gentrifydataTrain %>% dplyr::select(gentrification, changeinpoverty,changeinbachelor, changeinwhite,pctBachelors20,changein2544,houseprice20,rent,rent20,changeinhouseprice,newhousingunit, incomeChange,crimeChange, ForMig_Change, Density_Change,race),family="binomial"(link="logit"))

# Load necessary libraries
library(dplyr)
library(knitr)
library(kableExtra)

# Assuming recidivismModel and previous steps have been correctly run
gentrifyModel_sum <- summary(gentrifyModel)
coefficients_table <- as.data.frame(gentrifyModel_sum $coefficients)

# Apply significance stars based on p-values
coefficients_table$significance <- ifelse(coefficients_table$`Pr(>|z|)` < 0.001, '***',
                                         ifelse(coefficients_table$`Pr(>|z|)` < 0.01, '**',
                                                ifelse(coefficients_table$`Pr(>|z|)` < 0.05, '*',
                                                       ifelse(coefficients_table$`Pr(>|z|)` < 0.1, '.', ''))))



# Print the table with formatting
kable(coefficients_table %>% select(-significance, -`Pr(>|z|)`), align = "r") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed")) %>%
  footnote(general_title = "\n", general = "Table 3")
summary(gentrifyModel)
```

The model has a McFadden score of 0.48, suggesting a good prediction performance. 

```{r}
library(pscl)
library(plotROC)
library(pROC)
pR2(gentrifyModel ) 
```



```{r}
testProbs <- data.frame(Outcome = as.factor(gentrifydataTest $gentrification), Probs = predict(gentrifyModel, gentrifydataTest , type= "response"))
head(testProbs)
```


We can see that our model is better at prediciting the negatives rather than the positives. 

```{r}
ggplot(testProbs, aes(x = Probs, fill = as.factor(Outcome))) + 
  geom_density() +
  facet_grid(Outcome ~ .) +
  scale_fill_manual(values = palette2) + xlim(1, 0) +
  labs(x = "Gentrification", y = "Density of probabilities",
       title = "Distribution of predicted probabilities by observed outcome") + theme(strip.text.x = element_text(size = 18),
        legend.position = "none")
```


## Confusion matrix

The Confusion Matrix shows the number of observed instances of tracts gentrified. Each entry in the matrix provides a different comparison between observed and predicted, given the 15% threshold. The overall accuracy is 80%, which is acceptable. 

```{r}
testProbs <- 
  testProbs %>%
  mutate(predOutcome  = as.factor(ifelse(testProbs$Probs > 0.15 , 1, 0)))

caret::confusionMatrix(testProbs$predOutcome, testProbs$Outcome, 
                       positive = "1")
```

## ROC Curve

The AUC curve for our model is .83, proposing that we have a strong model with the feature engineered variables.

```{r}
ggplot(testProbs, aes(d = as.numeric(testProbs$Outcome), m = Probs)) +
  geom_roc(n.cuts = 50, labels = FALSE, colour = "#D98481") +
  style_roc(theme = theme_grey) +
  geom_abline(slope = 1, intercept = 0, size = 1.5, color = 'grey') +
  labs(title = "ROC Curve - Gentrification")
```

```{r}
pROC::auc(testProbs$Outcome, testProbs$Probs) # AUC: .73
```

## Cross Validation

```{r}


# Replace NA values in the 'gentrification' column with 0 (or another appropriate value)
gentrifydata_clean <- gentrifydata %>%
  select(gentrification,changeinpoverty,changeinbachelor, changeinwhite,pctBachelors20,changein2544,houseprice20,rent,rent20,changeinhouseprice,newhousingunit, incomeChange,crimeChange, ForMig_Change, Density_Change,race) %>%
  na.omit() 

# Convert 'gentrification' to a factor with levels that are valid R variable names
gentrifydata_clean$gentrification <- factor(gentrifydata_clean$gentrification, levels = c(0, 1), labels = c("No", "Yes"))

# Check the new levels
levels(gentrifydata_clean$gentrification)


customSummary <- function(data, lev = NULL, model = NULL) {
  # Assuming the positive class is labeled as 'True'
  prob <- ifelse(data[, "true"] >= 0.15, lev[2], lev[1])
  
  # Convert probabilities to factors with levels as per the actual outcomes
  prob <- factor(prob, levels = lev)
  
  # Calculate confusion matrix based metrics
  cm <- confusionMatrix(data = prob, reference = data$obs)
  
  # Return a list including metrics like Accuracy, Sensitivity (Recall), and Specificity
  out <- c(cm$overall['Accuracy'], cm$byClass['Sensitivity'], cm$byClass['Specificity'])
  names(out) <- c('Accuracy', 'Sensitivity', 'Specificity')
  out
}

# Assuming gentrifydata_clean is already loaded and cleaned
#gentrifydata_clean$gentrification <- factor(gentrifydata_clean$gentrification, levels = c(0, 1))

# Set up training control
ctrl <- trainControl(
  method = "cv",
  number = 10,
  classProbs = TRUE, 
  summaryFunction = twoClassSummary
)

# Fit the model
cvFit <- train(gentrification ~ .,
               data = gentrifydata_clean %>%
                 select(gentrification,changeinpoverty,changeinbachelor, changeinwhite,pctBachelors20,changein2544,houseprice20,rent,rent20,changeinhouseprice,newhousingunit, incomeChange,crimeChange, ForMig_Change, Density_Change,race),
               method = "glm",
               family = "binomial",
               metric = "Accuracy",
               trControl = ctrl)

# Print the fit model
print(cvFit)
```


The figure below plots the distribution of AUC, Sensitivity, and Specificity across the 100 folds. The tighter each distribution is to its mean, the more generalizable the model. Based on the result, our model generalizes well to ROC and sensitivity. 


```{r}
dplyr::select(cvFit$resample, -Resample) %>%
  gather(metric, value) %>%
  left_join(gather(cvFit$results[2:4], metric, mean)) %>%
  ggplot(aes(value)) + 
    geom_histogram(bins=35, fill = "#7892B5") +
    facet_wrap(~metric) +
    geom_vline(aes(xintercept = mean), colour = "#D98481", linetype = 3, size = 1.5) +
    scale_x_continuous(limits = c(0, 1)) +
    labs(x="Goodness of Fit", y="Count", title="CV Goodness of Fit Metrics",
         subtitle = "Across-fold mean reprented as dotted lines")

```




## Generalizability under Racial Context

We further examined the generalizability of the model under the racial context. There are more dominantly minority population tracts that got gentrified between 2015 and 2020 than the tracts with dominantly white populations. Our model has higher accuracy when predicting the dominantly white census tracts, especially when identifying the tracts that are not at the risk of gentrification, while this model performs better in correctly predicting the minority tracts that are at gentrification risk. However, this model generally over-predicts for both dominantly white and minority census tracts.


```{r}

gentrifydata %>%
    group_by(gentrification, race) %>%
    summarize(n = n()) %>%
    mutate(freq = n / sum(n)) %>% filter(gentrification == "1") %>%
    ggplot(aes(reorder(race, -freq), freq)) +
    geom_bar(stat = "identity", position = "dodge", fill = palette2) +
    labs(title = "Gentrification by Dominant Race",
         y = "Rate", x = "Race") +
    theme_minimal() + theme(axis.text.x = element_text(angle = 0, hjust = 1))
```
```{r}
gentrifydataTrain <- gentrifydata[ trainIndex,]
gentrifydataTest  <- gentrifydata[-trainIndex,]
```



```{r}

reg.noRace <- glm(gentrification ~ .,data=gentrifydataTrain %>% dplyr::select(gentrification, changeinpoverty,changeinbachelor, changeinwhite,pctBachelors20,changein2544,houseprice20,rent,rent20,changeinhouseprice,newhousingunit, incomeChange,crimeChange, ForMig_Change, Density_Change),family="binomial"(link="logit"))

reg.withRace <- glm(gentrification ~ .,data=gentrifydataTrain %>% dplyr::select(gentrification, changeinpoverty,changeinbachelor, changeinwhite,pctBachelors20,changein2544,houseprice20,rent,rent20,changeinhouseprice,newhousingunit, incomeChange,crimeChange, ForMig_Change, Density_Change,race),family="binomial"(link="logit"))

```


```{r}
testProbs_race <- 
  data.frame(class = gentrifydataTest$gentrification,
             probs = predict(reg.noRace, gentrifydataTest, type = "response"),
             Race = gentrifydataTest$race)
```



```{r}
mutate(testProbs_race, predClass = ifelse(probs >= .1, 1, 0)) %>%
  group_by(Race) %>%
  summarize(Observed.gentrification = sum(class) / n(),
            Predicted.gentrification = sum(predClass) / n()) %>%
  gather(Variable, Value, -Race) %>%
  ggplot(aes(Race, Value)) +
    geom_bar(aes(fill = Race), position="dodge", stat="identity") +
    scale_fill_manual(values = palette2) +
    facet_wrap(~Variable) +
    labs(title = "Observed and predicted gentrification", x = "Race", y = "Rate") +
    theme_minimal() + theme(axis.text.x = element_text(angle = 0, hjust = 1))
```


```{r}
iterateThresholds <- function(data, observedClass, predictedProbs, group) {
  observedClass <- enquo(observedClass)
  predictedProbs <- enquo(predictedProbs)
  group <- enquo(group)
  x = .01
  all_prediction <- data.frame()
  
  if (missing(group)) {
  
    while (x <= 1) {
    this_prediction <- data.frame()
    
    this_prediction <-
      data %>%
      mutate(predclass = ifelse(!!predictedProbs > x, 1,0)) %>%
      count(predclass, !!observedClass) %>%
      summarize(Count_TN = sum(n[predclass==0 & !!observedClass==0]),
                Count_TP = sum(n[predclass==1 & !!observedClass==1]),
                Count_FN = sum(n[predclass==0 & !!observedClass==1]),
                Count_FP = sum(n[predclass==1 & !!observedClass==0]),
                Rate_TP = Count_TP / (Count_TP + Count_FN),
                Rate_FP = Count_FP / (Count_FP + Count_TN),
                Rate_FN = Count_FN / (Count_FN + Count_TP),
                Rate_TN = Count_TN / (Count_TN + Count_FP),
                Accuracy = (Count_TP + Count_TN) / 
                           (Count_TP + Count_TN + Count_FN + Count_FP)) %>%
      mutate(Threshold = round(x,2))
    
    all_prediction <- rbind(all_prediction,this_prediction)
    x <- x + .01
  }
  return(all_prediction)
  }
  else if (!missing(group)) { 
   while (x <= 1) {
    this_prediction <- data.frame()
    
    this_prediction <-
      data %>%
      mutate(predclass = ifelse(!!predictedProbs > x, 1,0)) %>%
      group_by(!!group) %>%
      count(predclass, !!observedClass) %>%
      summarize(Count_TN = sum(n[predclass==0 & !!observedClass==0]),
                Count_TP = sum(n[predclass==1 & !!observedClass==1]),
                Count_FN = sum(n[predclass==0 & !!observedClass==1]),
                Count_FP = sum(n[predclass==1 & !!observedClass==0]),
                Rate_TP = Count_TP / (Count_TP + Count_FN),
                Rate_FP = Count_FP / (Count_FP + Count_TN),
                Rate_FN = Count_FN / (Count_FN + Count_TP),
                Rate_TN = Count_TN / (Count_TN + Count_FP),
                Accuracy = (Count_TP + Count_TN) / 
                           (Count_TP + Count_TN + Count_FN + Count_FP)) %>%
      mutate(Threshold = round(x, 2))
    
    all_prediction <- rbind(all_prediction, this_prediction)
    x <- x + .01
  }
  return(all_prediction)
  }
}
```






```{r}
# Calculate the ROC curve and AUC for each race
roc_list <- lapply(split(testProbs_race, testProbs_race$Race), function(subdata) {
  roc(response = subdata$class, predictor = subdata$probs)
})

# Create an empty ggplot object with the correct aesthetics
ggroc_combined <- ggplot() + theme_minimal() + 
  labs(title = "ROC Curves by race", x = "False Positive Rate", y = "True Positive Rate") +
  geom_abline(slope=1, intercept=0, linetype="dashed", color = "grey")

# Calculate the position for AUC annotations
max_specificity <- max(sapply(roc_list, function(x) max(1 - x$specificities)))
min_sensitivity <- min(sapply(roc_list, function(x) min(x$sensitivities)))

# Adding ROC curves to the plot with annotations for AUC
for (i in seq_along(roc_list)) {
  roc_data <- roc_list[[i]]
  auc_value <- auc(roc_data)
  ggroc_combined <- ggroc_combined + 
    geom_line(data = data.frame(fp = 1 - roc_data$specificities, tp = roc_data$sensitivities),
              aes(x = fp, y = tp), color = palette2[i], size = 0.5) +
    geom_point(data = data.frame(fp = 1 - roc_data$specificities, tp = roc_data$sensitivities),
               aes(x = fp, y = tp), color = palette2[i], size = 0.3) +
    annotate("text", x = max_specificity - 0.1, y = min_sensitivity + 0.05 * (length(roc_list) - i + 1), 
             label = paste(names(roc_list)[i], "AUC =", round(auc_value, 3)), 
             hjust = 1, color = palette2[i], size = 3.5)
}

print(ggroc_combined)
```

















# Validation on Chicago


The validation of our predictive model using Chicago's data, spanning the same years as the Los Angeles dataset, serves as a strategic choice to test the model's applicability and robustness across different urban settings. Choosing Chicago for validating our gentrification model developed from Los Angeles data is predicated on several factors:

* **Similar Urban Dynamics:** Both Chicago and Los Angeles are major metropolitan areas with diverse populations and significant economic disparities across different neighborhoods. 

* **Prevalence of Gentrification:** Like Los Angeles, Chicago has experienced noticeable gentrification, particularly in neighborhoods close to the city center and along key transit routes. 

* **Comprehensive Data Availability:** Chicago, similar to Los Angeles, has extensive data resources on demographics, urban infrastructure, and socio-economic indicators, which are crucial for a fair comparison and reliable validation of the predictive model.

This approach helps ascertain the model's generalizability and accuracy in predicting gentrification beyond the initial city, ensuring that the model can potentially be adapted for various urban environments with similar underlying patterns of change. The result of this step of validation shows that the model 



```{r cache = TRUE, message = FALSE, warning = FALSE,results='hide'}
# Read and process Chicago boundary data
chicagoBoundary <- 
  st_read(file.path(root.dir, "/Chapter5/chicagoBoundary.geojson")) %>%  # Read Chicago boundary data
  st_transform('ESRI:102271')  # Transform coordinate reference system



# Grocerystore
chicagogrocerystore <- read.socrata("https://data.cityofchicago.org/resource/3e26-zek2.json")

chicagogrocerystore <- chicagogrocerystore %>%
  mutate(
    location.coordinates = as.character(location.coordinates),  # Convert to character if not already
    coords = sapply(location.coordinates, function(x) {
      # Remove 'c(' and ')' from the string, split by ', ', and convert to numeric
      str <- gsub("c\\(|\\)", "", x)
      as.numeric(strsplit(str, ", ")[[1]])
    }, simplify = FALSE)  # Ensure output is a list
  ) %>%
  na.omit()  # Remove rows with NA values possibly due to incorrect parsing

chicagogrocerystore <- chicagogrocerystore %>%
  mutate(
    lon = sapply(coords, function(x) x[1]),  # Extract first element as longitude
    lat = sapply(coords, function(x) x[2])   # Extract second element as latitude
  ) %>%
  select(-coords, -location.coordinates) 
# Convert to an sf object with proper coordinates
chicagogrocerystore_sf <- st_as_sf(chicagogrocerystore, coords = c("lon", "lat"), crs = 4326, agr = "constant")%>%
st_transform('ESRI:102271') 




## Restaurant
restaurantchicago <- read.socrata("https://data.cityofchicago.org/resource/5udb-dr6f.json")

restaurantchicago <- restaurantchicago %>%
  dplyr::select(Y = latitude, X = longitude) %>%
  na.omit() %>%
  st_as_sf(coords = c("X", "Y"), crs = 4326, agr = "constant") %>% # Transforming to the specified CRS
st_transform('ESRI:102271')


# Renaming and transforming the dataframe
schoolchicago <- read.socrata("https://data.cityofchicago.org/resource/95e9-uzwt.json")
schoolchicago <- schoolchicago %>%
  mutate(
    the_geom.coordinates = as.character(the_geom.coordinates),  # Convert to character if not already
    coords = sapply(the_geom.coordinates, function(x) {
      # Remove 'c(' and ')' from the string, split by ', ', and convert to numeric
      str <- gsub("c\\(|\\)", "", x)
      as.numeric(strsplit(str, ", ")[[1]])
    }, simplify = FALSE)  # Ensure output is a list
  ) %>%
  na.omit()  # Remove rows with NA values possibly due to incorrect parsing

schoolchicago <- schoolchicago %>%
  mutate(
    lon = sapply(coords, function(x) x[1]),  # Extract first element as longitude
    lat = sapply(coords, function(x) x[2])   # Extract second element as latitude
  ) %>%
  select(-coords, -the_geom.coordinates) 
# Convert to an sf object with proper coordinates
schoolchicago_sf <- st_as_sf(schoolchicago, coords = c("lon", "lat"), crs = 4326, agr = "constant")%>%
st_transform('ESRI:102271')
schoolchicago_sf <- schoolchicago_sf%>%
dplyr::select(geometry)



# Read the CSV file into an R data frame
#crime_data <- read.csv("C:/Users/jiahangl/OneDrive - PennO365/MUSA508/A4/crime2018.csv")
#crime_data <- crime_data %>%
  #filter(!is.na(Longitude) & !is.na(Latitude))
```

## Loading census data

```{r cache = TRUE, message = FALSE, warning = FALSE,results='hide'}

# Fetch the data for LA, LA County, CA,2015
acs_chi <- get_acs(
  geography = "tract",
  variables = variables,
  year = 2015,
  state = "17",
  county = "031",
  geometry = TRUE,
  survey = "acs5",
  output = "wide"
)%>%
st_transform('ESRI:102271')



# Fetch the data for LA, LA County, CA,2020
acs_chi20 <- get_acs(
  geography = "tract",
  variables = variables,
  year = 2020,
  state = "17",
  county = "031",
  geometry = TRUE,
  survey = "acs5",
  output = "wide"
)%>%
  st_transform('ESRI:102271')
vars <- load_variables(2020, "acs5", cache = TRUE)




# Assuming acs_la is already an sf object with proper geometry handling
acs_chi <- acs_chi %>%
  rename(
    totalPop = B01001_001E,
    male = B01001_002E,
    female = B01001_026E,
    age_18_24 = B01001_007E,
    age_25_44 = B01001_012E,
    age_45_64 = B01001_016E,
    age_65plus = B01001_020E,
    white = B02001_002E,
    popblack = B02001_003E,
    latino = B03001_003E,
    other_race = B02001_004E,
    income_less_20k = B19001_002E,
    income_20k_40k = B19001_003E,
    income_40k_60k = B19001_006E,
    income_60k_80k = B19001_008E,
    income_80k_100k = B19001_010E,
    income_more_100k = B19001_012E,
    migration_total = B07001_001E,
    migration_within_county = B07001_017E,
    migration_different_county_same_state = B07001_033E,
    migration_different_state = B07001_049E,
    migration_from_abroad = B07001_065E,
    edu_less_high_school = B15001_002E,
    edu_high_school_grad = B15001_003E,
    edu_some_college = B15001_005E,
    edu_bachelors = B15001_009E,
    edu_grad_professional = B15001_010E,
    total_housing_units = B25001_001E,
    total_poverty = B06012_002E,
    vacant_units = B25002_003E,
    white_houseOwner = B25006_002E,
    total_occupied_units = B25006_001E,
    median_HH_income = B19013_001E,
    houseprice = B25077_001E,
    rent = B25031_001E,
    travetimetowork = B08133_001E
  ) %>%
  select(-starts_with("B"),-NAME) %>%
  mutate(
    WhiteHOrate = white_houseOwner / total_occupied_units,
    pctBachelors = ifelse(totalPop > 0, (edu_bachelors + edu_grad_professional) / totalPop, 0),
    pctPoverty = ifelse(totalPop > 0, total_poverty / totalPop, 0),
    pctWhitePop = ifelse(totalPop > 0, white / totalPop, 0),
    pctLatinoPop = ifelse(totalPop > 0, latino / totalPop, 0),
    pctBlackPop = ifelse(totalPop > 0, popblack / totalPop, 0),
    pctMigration = ifelse(totalPop > 0, migration_total / totalPop, 0),
    pctForeignMig = ifelse(totalPop > 0, migration_from_abroad / totalPop, 0),
    pct2540 = ifelse(totalPop > 0,  age_25_44 / totalPop, 0),
    landArea = st_area(geometry), 
    popDensity = totalPop / as.numeric(landArea)
  )


acs_chi20 <- acs_chi20 %>%
  rename(totalPop20 = "B01001_001E",
  male20 = "B01001_002E",
  female20 = "B01001_026E",
  age_18_2420 = "B01001_007E",
  age_25_4420 = "B01001_012E",
  age_45_6420 = "B01001_016E",
  age_65plus20 = "B01001_020E",
  white20 = "B02001_002E",
  popblack20 = "B02001_003E",
  latino20 = "B03001_003E",
  other_race20 = "B02001_004E",
  income_less_20k20 = "B19001_002E",
  income_20k_40k20 = "B19001_003E",
  income_40k_60k20 = "B19001_006E",
  income_60k_80k20 = "B19001_008E",
  income_80k_100k20 = "B19001_010E",
  income_more_100k20 = "B19001_012E",
  migration_total20 = "B07001_001E",
  migration_within_county20 = "B07001_017E",
  migration_different_county_same_state20 = "B07001_033E",
  migration_different_state20 = "B07001_049E",
  migration_from_abroad20 = "B07001_065E",
  edu_less_high_school20 = "B15001_002E",
  edu_high_school_grad20 = "B15001_003E",
  edu_some_college20 = "B15001_005E",
  edu_bachelors20 = "B15001_009E",
  edu_grad_professional20 = "B15001_010E",
  total_housing_units20 = "B25001_001E",
  total_poverty20 = "B06012_002E",
  vacant_units20 = "B25002_003E",
  white_houseOwner20 = "B25006_002E",
  total_Ooccupied_Uunits20 = "B25006_001E",
  median_HH_income20 = "B19013_001E",
  houseprice20 = "B25077_001E",
  rent20="B25031_001E"
)%>%
  dplyr::select(-starts_with("B")) %>% 
  mutate(WhiteHOrate20 = white_houseOwner20/total_Ooccupied_Uunits20,
         pctBachelors20 = ifelse(totalPop20 > 0, ((edu_bachelors20 + edu_grad_professional20) / totalPop20),0),
         pctPoverty20 = ifelse(totalPop20 > 0, total_poverty20 / totalPop20, 0),
         pctWhitePop20 = ifelse(totalPop20 > 0, white20 / totalPop20, 0),
         pctLatinoPop20 = ifelse(totalPop20 > 0, latino20 / totalPop20, 0),
         pctBlackPop20 = ifelse(totalPop20 > 0, popblack20 / totalPop20, 0),
         pctMigration20 = ifelse(totalPop20 > 0, migration_total20 / totalPop20, 0),
         pctForeignMig20 = ifelse(totalPop20 > 0, migration_from_abroad20 / totalPop20, 0),
         pct254020 = ifelse(totalPop20 > 0,  age_25_4420 / totalPop20, 0),
         landArea20 = st_area(geometry), 
         popDensity20 = totalPop20 / as.numeric(landArea20))



# Drop Margin Columns from ACS
datachicago<-st_join(acs_chi,acs_chi20)
chicagoBoundary <- st_transform(chicagoBoundary, crs = st_crs(datachicago))
tractchicagoclipped <- st_intersection(datachicago, chicagoBoundary)
tractchicagogeography <- tractchicagoclipped %>%
  dplyr::select(GEOID.x, geometry)%>%
  mutate(GEOID=GEOID.x)



```






## Measuring Gentrification

```{r cache = TRUE, message = FALSE, warning = FALSE,results='hide'}


# Define variables for ACS data retrieval

variables <- c(med_income = "B19013_001E",  # Median household income
               total_bachelors = "B16010_041E",  # with Bachelor's degree or higher
               med_home_value = "B25077_001E")  # Median home value


# Fetch ACS data for 2010 and 2015
acs2014_chicago <- get_acs(geography = "tract", variables = variables, year = 2014, 
                   survey = "acs5", state = 17, county = 031, geometry = TRUE,output = "wide") %>% 
st_transform('ESRI:102271')


acs2020_chicago <- get_acs(geography = "tract", variables = variables, year = 2020, 
                   survey = "acs5", state = 17, county = 031, geometry = TRUE,output = "wide") %>% 
  select(-matches("M$"))%>% 
st_transform('ESRI:102271')

acs2015_chicago <- get_acs(geography = "tract", variables = variables, year = 2015, 
                   survey = "acs5", state = 17, county = 031, geometry = TRUE,output = "wide") %>% 
  select(-matches("M$"))%>% 
st_transform('ESRI:102271')

# Drop geometry for joining data on attributes
acs2014_nogeom_chicago <- st_drop_geometry(acs2014_chicago)
acs2020_nogeom_chicago <- st_drop_geometry(acs2020_chicago)
acs2015_nogeom_chicago <- st_drop_geometry(acs2015_chicago)

acs2014_nogeom_chicago <- acs2014_nogeom_chicago %>%
  rename_with(~paste0(., ".2014"), matches("^med_income|^total_bachelors|^med_home_value"))

acs2020_nogeom_chicago <- acs2020_nogeom_chicago %>%
  rename_with(~paste0(., ".2020"), matches("^med_income|^total_bachelors|^med_home_value"))
acs2015_nogeom_chicago <- acs2015_nogeom_chicago %>%
  rename_with(~paste0(., ".2015"), matches("^med_income|^total_bachelors|^med_home_value"))

gentrified_data_chicago <- left_join(acs2014_nogeom_chicago, acs2020_nogeom_chicago, by = "GEOID") %>%
  left_join(acs2015_nogeom_chicago, by = "GEOID")
gentrified_data_chicago <- gentrified_data_chicago %>%
  mutate(
    income_change_2020_2015_chicago = (`med_income.2020` - `med_income.2015`) / `med_income.2015` * 100,
    education_change_2020_2015_chicago = (`total_bachelors.2020` - `total_bachelors.2015`) / `total_bachelors.2015` * 100,
    home_value_change_2020_2015_chicago = (`med_home_value.2020` - `med_home_value.2015`) / `med_home_value.2015` * 100,) %>% 
  select(-matches("^NAME"))
   
# Convert it back
gentrified_data_sf_chicago <- st_as_sf(gentrified_data_chicago, geometry = st_geometry(acs2014_chicago), crs = st_crs(acs2014_chicago))


```


```{r cache = TRUE, message = FALSE, warning = FALSE,results='hide'}

thresholds_2014_chicago <- gentrified_data_sf_chicago %>%
  summarise(
    threshold_home_value_2014_chicago = quantile(med_home_value.2014, 0.4, na.rm = TRUE),
    threshold_income_2014_chicago = quantile(med_income.2014, 0.4, na.rm = TRUE)
  )

# Convert thresholds to a simpler format if needed (depending on the context)
thresholds_2014_chicago <- as.data.frame(thresholds_2014_chicago)

# Define eligibility in 2009 based on population, home value, and income
eligible_tracts_chicago <- gentrified_data_sf_chicago %>%
  filter(#population.2009 > 500,
         med_home_value.2014 < thresholds_2014_chicago$threshold_home_value_2014_chicago,
         med_income.2014 < thresholds_2014_chicago$threshold_income_2014_chicago)

# Calculate changes from 2010 to 2015
changes_2020_2015_chicago <- eligible_tracts_chicago %>%
  mutate(
    home_value_change_chicago = med_home_value.2020 - med_home_value.2015,
    income_change_chicago = med_income.2020 - med_income.2015,
    education_change_chicago = total_bachelors.2020 - total_bachelors.2015
  )

# Calculate 60th percentile changes as new thresholds for changes
thresholds_2015_chicago <- changes_2020_2015_chicago %>%
  summarise(
    top_40th_home_value_change_chicago = quantile(home_value_change_chicago, 0.4, na.rm = TRUE),
    top_40th_income_change_chicago = quantile(income_change_chicago, 0.4, na.rm = TRUE),
    top_40th_education_change_chicago = quantile(education_change_chicago, 0.4, na.rm = TRUE)
  )

# Convert to a simpler format
thresholds_2015_chicago <- as.data.frame(thresholds_2015_chicago)

# Apply change criteria for 2010-2015
gentrified_tracts_chicago <- changes_2020_2015_chicago %>%
  filter(home_value_change_chicago > thresholds_2015_chicago$top_40th_home_value_change_chicago,
         #home_value_change >0,
         income_change_chicago > thresholds_2015_chicago$top_40th_income_change_chicago,
         education_change_chicago > thresholds_2015_chicago$top_40th_education_change_chicago)

# Mapping the results
#ggplot(gentrified_tracts_chicago) +
  #geom_sf(fill = "blue", color = "black") +
  #labs(title = "Gentrified Areas in 2020",
       #subtitle = "Tracts meeting all criteria for significant changes") +
  #theme_minimal()


# Switch to your own path, Xia and Jiahang!
chicago_city_boundary <-   st_read(file.path(root.dir, "/Chapter5/chicagoBoundary.geojson")) %>%  # Read Chicago boundary data
  st_transform(st_crs(acs2014_chicago)) 




# THIS IS THE DATASET!!!!!!!!!
gentrified_tracts_chicago <- st_intersection(gentrified_tracts_chicago, chicago_city_boundary)

gentrified_tract_chicagonew <- st_drop_geometry(gentrified_tracts_chicago)%>%
   mutate(gentrification = 1)

ggplot() +
  geom_sf(data = chicago_city_boundary, fill = "grey80", color = "black", size = 0.2, alpha = 0.5) +
  geom_sf(data = gentrified_tracts_chicago, fill = "#7892B5", color = "black", size = 0.5, alpha = 0.8) +
  labs(
    title = "Gentrified Areas in Chicago, 2020",
    subtitle = "Tracts meeting all criteria for significant changes"
  ) +
  theme_minimal()

```


## Feature Engineering

### Identify Changes in Census Data

```{r cache = TRUE, message = FALSE, warning = FALSE,results='hide'}
library(sf)
library(dplyr)

# Drop geometry from acs_la and acs_la20 and join them
acs_chi_nogeom <- st_drop_geometry(acs_chi)
acs_chi20_nogeom <- st_drop_geometry(acs_chi20)
datachi <- left_join(acs_chi_nogeom, acs_chi20_nogeom, by = "GEOID")


# Convert acs2015 to a spatial dataframe and select relevant columns
datageographychi <- st_as_sf(acs_chi, geometry = "geometry", crs = 4326) %>%
  select(GEOID, geometry)

# Joining non-spatial data with spatial data and ensuring it remains a spatial dataframe
datanewchi <- left_join(datachi, datageographychi, by = "GEOID")
datanewchi <- st_as_sf(datanewchi, geometry = st_geometry(acs_chi), crs = st_crs(acs_chi))

# Read and transform the boundary to match LA's local projection
chicagoBoundary <- 
  st_read(file.path(root.dir, "/Chapter5/chicagoBoundary.geojson")) %>%  # Read Chicago boundary data
  st_transform('ESRI:102271')  # Transform coordinate reference system

# Transform datanew to match the CRS of boundary
datanewchi <- st_transform(datanewchi, st_crs(chicagoBoundary))

# Perform the intersection of boundary and datanew
tractclippedchi <- st_intersection(chicagoBoundary, datanewchi)

# Select GEOID and geometry from the intersection result
tractgeographychi <- tractclippedchi %>%
  select(GEOID, geometry)

# Correcting the assignment and ensuring proper use of the pipe operator
tractclippednewchi <- tractclippedchi %>%
  left_join(gentrified_tract_chicagonew[, c("GEOID", "gentrification")], by = "GEOID")

# Assuming your dataframe is called 'data'
tractclippednewchi <- tractclippednewchi %>%
  mutate(gentrification = replace_na(gentrification, 0))

```

```{r}
tractclippednewchi <- tractclippednewchi  %>%
  mutate(changeinpoverty = pctPoverty20 - pctPoverty,
         changeinbachelor = pctBachelors20 - pctBachelors,
         changeinwhite = pctWhitePop20 - pctWhitePop,
         changeinhouseprice=houseprice20-houseprice,
         changeinrent=rent20-rent,
         changein2544= pct254020- pct2540,
         newhousingunit=total_housing_units20-total_housing_units,
         migChange = pctMigration20 - pctMigration20, 
         incomeChange = median_HH_income20 - median_HH_income, 
         minorityChange = (1-pctWhitePop20) - (1-pctWhitePop),
         ForMig_Change = pctForeignMig20 - pctForeignMig,
         Density_Change = popDensity20 - popDensity)
```

### Calculate Crime by Tracts

```{r message=FALSE, warning=FALSE, cache=FALSE, include=FALSE, paged.print=FALSE, results='hide'}


    crime2015_chi <- 
      read.socrata("https://data.cityofchicago.org/Public-Safety/Crimes-2015/vwwp-7yr9") %>% 
      dplyr::select(-Date, -Updated.On) %>%
      mutate(x = gsub("[()]", "", Location)) %>%
      separate(x, into = c("Y", "X"), sep = ",") %>%
      mutate(X = as.numeric(X), Y = as.numeric(Y)) %>% 
      na.omit() %>%
      st_as_sf(coords = c("X", "Y"), crs = 4326, agr = "constant") %>%
      st_transform('ESRI:102271') %>%
      distinct()


```

```{r message=FALSE, warning=FALSE, cache=FALSE, paged.print=FALSE, results='hide', include=FALSE}
crime2020_chi <- 
    read.socrata("https://data.cityofchicago.org/Public-Safety/Crimes-2020/qzdf-xmn8") %>% 
    dplyr::select(-Date, -Updated.On) %>%
    mutate(x = gsub("[()]", "", Location)) %>%
    separate(x,into= c("Y","X"), sep=",") %>%
    mutate(X = as.numeric(X),Y = as.numeric(Y)) %>% 
    na.omit() %>%
    st_as_sf(coords = c("X", "Y"), crs = 4326, agr = "constant")%>%
    st_transform('ESRI:102271') %>% 
    distinct()
```









```{r}
crime2015pointchi <- crime2015_chi %>%
  st_join(tractgeographychi, left = F)
crime2015numberchi <- crime2015pointchi %>%
  group_by(GEOID) %>%  
  summarise(crime2015countchi = n())
  
crime2015numberchi <- crime2015numberchi
crime2015numberchi <- st_set_geometry(crime2015numberchi, NULL)

tractclippednewchi <- left_join(tractclippednewchi, crime2015numberchi, by = c("GEOID"))
```

```{r}
crime2020pointchi <- crime2020_chi %>%
  st_join(tractgeographychi, left = F)
crime2020numberchi <- crime2020pointchi %>%
  group_by(GEOID) %>%  # Replace TRACT_ID with the actual identifier field for tracts
  summarise(crime2020countchi = n())
  
crime2020numberchi <- crime2020numberchi
crime2020numberchi <- st_set_geometry(crime2020numberchi, NULL)

tractclippednewchi <- left_join(tractclippednewchi,crime2020numberchi, by = c("GEOID"))
```

```{r}
tractclippednewchi <- tractclippednewchi %>%
  mutate(crimeChangechi = crime2020countchi - crime2015countchi)

```


## Modeling building

```{r}
tractclippednewchi <- tractclippednewchi %>%
  mutate(race = ifelse(pctWhitePop < 0.5, "Minority", "White"))
```


### Logistic regression
```{r}

gentrifydatachi<-  st_set_geometry(tractclippednewchi , NULL)
# Correct use of set.seed(
set.seed(479)

# Assuming gentrifydatachi is your data frame and NAME is a column in your dataframe
trainIndex <- caret::createDataPartition(y = gentrifydatachi$gentrification, p = 0.65, list = FALSE, times = 1)

```



```{r}
gentrifydatachiTrain <- gentrifydatachi[ trainIndex,]
gentrifydatachiTest  <- gentrifydatachi[-trainIndex,]

gentrifyModelchi <- glm(gentrification ~ .,data=gentrifydatachiTrain %>% dplyr::select(gentrification, changeinpoverty,changeinbachelor, changeinwhite,pctBachelors20,changein2544,houseprice20,rent,rent20,changeinhouseprice,newhousingunit, incomeChange,crimeChangechi, ForMig_Change, Density_Change,race),family="binomial"(link="logit"))

# Load necessary libraries
library(dplyr)
library(knitr)
library(kableExtra)

# Assuming recidivismModel and previous steps have been correctly run
gentrifyModel_sumchi <- summary(gentrifyModelchi)
coefficients_table <- as.data.frame(gentrifyModel_sumchi $coefficients)

# Apply significance stars based on p-values
coefficients_table$significance <- ifelse(coefficients_table$`Pr(>|z|)` < 0.001, '***',
                                         ifelse(coefficients_table$`Pr(>|z|)` < 0.01, '**',
                                                ifelse(coefficients_table$`Pr(>|z|)` < 0.05, '*',
                                                       ifelse(coefficients_table$`Pr(>|z|)` < 0.1, '.', ''))))



# Print the table with formatting
kable(coefficients_table %>% select(-significance, -`Pr(>|z|)`), align = "r") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed")) %>%
  footnote(general_title = "\n", general = "Table 3")
summary(gentrifyModelchi)
```


### Model Evaluation

```{r}
library(pscl)
library(plotROC)
library(pROC)
pR2(gentrifyModelchi ) #McFadden: 0.246
```



```{r}
testProbschi <- data.frame(Outcome = as.factor(gentrifydatachiTest$gentrification), Probs = predict(gentrifyModelchi, gentrifydatachiTest , type= "response"))
head(testProbschi)
```




```{r}
ggplot(testProbschi, aes(x = Probs, fill = as.factor(Outcome))) + 
  geom_density() +
  facet_grid(Outcome ~ .) +
  scale_fill_manual(values = palette2) + xlim(1, 0) +
  labs(x = "Gentrification", y = "Density of probabilities",
       title = "Distribution of predicted probabilities by observed outcome") + theme(strip.text.x = element_text(size = 18),
        legend.position = "none")
```


### Confusion matrix

```{r}
testProbschi <- 
  testProbschi %>%
  mutate(predOutcome  = as.factor(ifelse(testProbschi$Probs > 0.12 , 1, 0)))

caret::confusionMatrix(testProbschi$predOutcome, testProbschi$Outcome, 
                       positive = "0")
```


```{r}
ggplot(testProbs, aes(d = as.numeric(testProbs$Outcome), m = Probs)) +
  geom_roc(n.cuts = 50, labels = FALSE, colour = "#D98481") +
  style_roc(theme = theme_grey) +
  geom_abline(slope = 1, intercept = 0, size = 1.5, color = 'grey') +
  labs(title = "ROC Curve - Gentrification")
```


# Conclusion

Based on the model, we have some recommendations for implementation:


**1. Projecting Five-Year Scenarios**
The model is calibrated to predict changes based on a five-year historical data pattern. Therefore, it is best suited for forecasting similar five-year future intervals. To leverage its predictive power effectively, we recommend utilizing it to project outcomes from 2020 to 2025, and similarly for subsequent five-year periods. This approach aligns the model's strengths with its intended application, ensuring relevance and accuracy in its predictions.

**2. Regular Data Updates and community engagaement**
For the model to remain effective, it is crucial to incorporate the latest data regularly. As urban demographics and economic conditions evolve, updating the dataset for the next five-year span (e.g., 2025 - 2030) as soon as new data becomes available will enable the model to capture emerging trends and shifts in urban development. This continuous updating process not only enhances the modelâ€™s accuracy but also maintains its relevance in dynamic urban planning contexts.

**3. Model Customization for Highly Gentrified Cities**
Cities that have undergone significant gentrification, such as New York, present unique challenges that may not be fully addressed by a general model. In these cases, it is advisable to develop specialized models that consider specific local factors and the saturation of gentrification effects. Such tailored models should focus on more granular aspects of change, such as shifts in micro-neighborhood demographics or the impact of policy changes, to provide useful insights for urban planners and policymakers.

**4. Incorporating Localized Factors**
Consider enhancing the model by integrating more localized factors that influence gentrification, such as zoning laws, public transportation developments, and economic incentives. This addition can improve the model's ability to forecast gentrification impacts more accurately within specific contexts.

Introduce the predictive model as a state-of-the-art tool designed to identify and forecast gentrification trends within urban areas. Highlight that this model leverages both spatial and non-spatial data from the American Community Survey, covering demographic shifts and socio-economic changes from 2015 to 2020.I would recommend the city to invest in the development of this model to improve the distribution of socioeconomic resources.



# Reference

DeVylder, J., Fedina, L., & Jun, H.-J. (2019). The Neighborhood Change and Gentrification Sc
ale: Factor analysis of a novel self-report measure. Social Work Research, 43(4), 279â€“284. https://doi.org/10.1093/swr/svz015

Hwang, J. (2016). The social construction of a gentrifying neighborhood: Reifying and redefining identity and boundaries in inequality. Urban Affairs Review, 52(1), 98-128.

Hwang, J. (2015). Gentrification in changing cities: Immigration, new diversity, and racial inequality in neighborhood renewal. The Annals of the American Academy of Political and Social Science, 660(1), 319-340.

Hwang, J., & Sampson, R. J. (2014). Divergent pathways of gentrification: Racial inequality and the social order of renewal in Chicago neighborhoods. American sociological review, 79(4), 726-751.

Richardson, J., Mitchell, B., & Edlebi, J. (2020). Gentrification and disinvestment 2020.


